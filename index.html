<!doctype html>
<html>
<head>
<script type="module">
  // Import Firebase SDKs
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
  import { getDatabase, ref, onValue, query, limitToLast } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-database.js";

  // Your web app's Firebase configuration
  const firebaseConfig = {
      apiKey: "AIzaSyAlImS2cKAHhuvcpj3Y1ZC1V6LpQMH1DkI", // Gunakan API Key yang sama
      authDomain: "splash-kelompok28.firebaseapp.com",
      databaseURL: "https://splash-kelompok28-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "splash-kelompok28",
      storageBucket: "splash-kelompok28.firebasestorage.app",
      messagingSenderId: "797027515264",
      appId: "1:797027515264:web:8404eb711cfb5a0d159f65",
      measurementId: "G-KSCXTLCMTL"
  };

  // Initialize Firebase
  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);

  let lineChart, lineChartMlps;
  // ... (Konstanta dan fungsi lain seperti setGauge, mkLine, pctToMlps tetap sama) ...
  
  // ================= FIREBASE LISTENERS =================

  const updateRealtimeUI = (data) => {
      // Ambil data realtime dari Firebase
      const j = data.val();
      if (!j) return;

      const f1 = j.flow1, f2 = j.flow2;
      setGauge('g1', f1);
      setGauge('g2', f2);

      const pumpEl = document.getElementById('pumpLabel');
      pumpEl.innerText = j.pumpState ? 'ON' : 'OFF'; // Gunakan pumpState dari Firebase
      pumpEl.className = 'indicator ' + (j.pumpState ? 'on' : 'off');

      const valveEl = document.getElementById('valveLabel');
      valveEl.innerText = j.valveState ? 'OPEN' : 'CLOSED'; // Gunakan valveState

      const leak = j.leakLockout || false;

      if (leak) {
          document.getElementById('leakBadge').className = 'badge danger';
          document.getElementById('leakBadge').innerText = 'WATER LEAKAGE DETECTED! (LOCKED)';
          // ... (logika gambar kebocoran) ...
      } else {
          document.getElementById('leakBadge').className = 'badge ok';
          document.getElementById('leakBadge').innerText = 'SYSTEM OK';
          // ... (logika gambar OK) ...
      }
      
      document.getElementById('lastUpdate').innerText = new Date(j.timestamp).toLocaleTimeString();
      // Hilangkan tombol toggle/kontrol manual karena hanya monitoring
  };

  const updateHistoryChart = (data) => {
      const history = data.val();
      if (!history) return;

      const keys = Object.keys(history);
      keys.sort((a, b) => parseInt(a) - parseInt(b)); // Urutkan berdasarkan timestamp (key)

      // Hanya ambil N data terakhir untuk performa
      const totalSamples = keys.length;
      const displaySize = parseInt(document.getElementById('zoomRange').value || '30');
      const startKeyIndex = Math.max(0, totalSamples - displaySize);
      
      const labels = [], d1 = [], d2 = [], m1 = [], m2 = [];

      for (let i = startKeyIndex; i < totalSamples; i++) {
          const tms = keys[i];
          const p = history[tms];
          
          const f1 = p.f1;
          const f2 = p.f2;
          
          labels.push(new Date(parseInt(tms)).toLocaleTimeString());
          d1.push(f1);
          d2.push(f2);
          m1.push(pctToMlps(f1));
          m2.push(pctToMlps(f2));
      }

      lineChart.data.labels = labels;
      lineChart.data.datasets[0].data = d1;
      lineChart.data.datasets[1].data = d2;
      lineChart.update();

      lineChartMlps.data.labels = labels;
      lineChartMlps.data.datasets[0].data = m1;
      lineChartMlps.data.datasets[1].data = m2;
      lineChartMlps.update();

      document.getElementById('dataRangeInfo').innerText = 
          `Showing last ${labels.length} data of ${totalSamples}`;
  };

  // Listener untuk data Realtime (Gauge)
  const rtRef = ref(db, 'realtime');
  onValue(rtRef, updateRealtimeUI);

  // Listener untuk data History (Chart), batasi hanya 100 data terakhir
  const histQuery = query(ref(db, 'history'), limitToLast(100)); // Ambil 100 data terakhir
  onValue(histQuery, updateHistoryChart);


  window.addEventListener('load', () => {
      mkLine();
      // Tidak perlu setInterval(fetchData, 1000) lagi, karena onValue bersifat realtime/listener
      // Tambahkan event listener untuk zoomRange agar tetap berfungsi
      document.getElementById('zoomRange').addEventListener('input', () => {
          document.getElementById('zoomVal').innerText = document.getElementById('zoomRange').value;
          // Panggil ulang updateHistoryChart dengan data terakhir dari Firebase
          // Anda mungkin perlu menyimpan data history yang diambil terakhir di variabel global
          // Atau ambil ulang data dari Firebase dengan limit yang sesuai. Untuk kesederhanaan, kita pakai 100 terakhir.
          onValue(histQuery, updateHistoryChart, { onlyOnce: true });
      });
  });

  // Hapus semua fungsi/kode yang terkait dengan webserver lokal ESP32 seperti fetchData, toggleBtn, openValveBtn, closeValveBtn, downloadCsv, downloadPng, prevBtn, nextBtn karena akan menjadi kompleks jika dikaitkan dengan struktur data Firebase.
  // Jika ingin tetap ada tombol Download CSV/PNG, Anda harus memuat seluruh data history terlebih dahulu dari Firebase.
</script>
